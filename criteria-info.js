/**
 * Конфигурация информации о критериях принятия решений
 * Содержит метаданные и описания для всех критериев
 */
const CriteriaInfo = {
    wald: {
        name: 'Критерий Вальда (максимин)',
        description: 'Критерий крайнего пессимизма, ориентированный на наихудшие условия.',
        formula: 'W_i = min(a_ij) по j, где a_ij - элементы матрицы',
        maxFormula: 'max(W_i) по i',
        calculation: 'Для каждой стратегии находится минимальный выигрыш (наихудший исход), затем выбирается стратегия с максимальным значением среди этих минимальных выигрышей.',
        steps: [
            'Для каждой строки матрицы (стратегии) найти минимальное значение',
            'Среди найденных минимальных значений выбрать максимальное',
            'Соответствующая стратегия является оптимальной по критерию Вальда'
        ],
        interpretation: 'Гарантирует, что в наихудших условиях потери будут минимальны. Подходит для консервативных решений.'
    },
    
    maximax: {
        name: 'Критерий Максимакс',
        description: 'Критерий крайнего оптимизма, ориентированный на наилучшие условия.',
        formula: 'M_i = max(a_ij) по j',
        maxFormula: 'max(M_i) по i',
        calculation: 'Для каждой стратегии находится максимальный выигрыш (наилучший исход), затем выбирается стратегия с максимальным значением среди этих максимальных выигрышей.',
        steps: [
            'Для каждой строки матрицы (стратегии) найти максимальное значение',
            'Среди найденных максимальных значений выбрать максимальное',
            'Соответствующая стратегия является оптимальной по критерию Максимакс'
        ],
        interpretation: 'Ориентирован на максимально возможный выигрыш. Подходит для рискованных решений с потенциалом высокой прибыли.'
    },
    
    savage: {
        name: 'Критерий Сэвиджа (минимаксного риска)',
        description: 'Критерий минимизации максимальных потерь (сожалений).',
        formula: 'Сначала строится матрица рисков: r_ij = max(a_kj) по k - a_ij',
        minFormula: 'min(max(r_ij) по j) по i',
        calculation: 'Сначала строится матрица рисков (сожалений), где каждый элемент показывает, сколько теряет ЛПР, выбрав данную стратегию при данном состоянии природы. Затем для каждой стратегии находится максимальный риск, и выбирается стратегия с минимальным значением среди этих максимальных рисков.',
        steps: [
            'Построить матрицу рисков: для каждого столбца найти максимальное значение, затем вычесть из него все значения столбца',
            'Для каждой строки матрицы рисков найти максимальное значение',
            'Среди найденных максимальных рисков выбрать минимальный',
            'Соответствующая стратегия является оптимальной по критерию Сэвиджа'
        ],
        interpretation: 'Минимизирует максимальные возможные потери. Компромиссный подход между оптимизмом и пессимизмом.'
    },
    
    hurwitz: {
        name: 'Критерий Гурвица',
        description: 'Компромиссный критерий, учитывающий как оптимистичный, так и пессимистичный подходы.',
        formula: 'H_i = α * max(a_ij) + (1-α) * min(a_ij), где α ∈ [0,1]',
        maxFormula: 'max(H_i) по i',
        calculation: 'Для каждой стратегии вычисляется взвешенная сумма максимального и минимального выигрышей, где α - коэффициент оптимизма.',
        steps: [
            'Для каждой строки матрицы найти минимальное и максимальное значения',
            'Вычислить значение критерия: H = α * max + (1-α) * min',
            'Выбрать стратегию с максимальным значением H'
        ],
        interpretation: 'При α=1 превращается в критерий Максимакс, при α=0 - в критерий Вальда. Позволяет регулировать степень оптимизма ЛПР.'
    },
    
    bayes: {
        name: 'Критерий Байеса (максимум математического ожидания)',
        description: 'Критерий для условий риска, максимизирующий ожидаемый выигрыш.',
        formula: 'B_i = Σ (p_j * a_ij), где p_j - вероятность j-го состояния природы',
        maxFormula: 'max(B_i) по i',
        calculation: 'Для каждой стратегии вычисляется математическое ожидание выигрыша как сумма произведений выигрышей на соответствующие вероятности состояний природы.',
        steps: [
            'Умножить каждый элемент строки на вероятность соответствующего состояния природы',
            'Сложить полученные произведения для каждой строки',
            'Выбрать стратегию с максимальной суммой'
        ],
        interpretation: 'Обеспечивает максимальный средний выигрыш при многократном повторении ситуации. Требует знания вероятностей.'
    },
    
    laplace: {
        name: 'Критерий Лапласа (равновозможных событий)',
        description: 'Частный случай критерия Байеса при равных вероятностях всех состояний.',
        formula: 'L_i = (1/n) * Σ a_ij, где n - количество состояний природы',
        maxFormula: 'max(L_i) по i',
        calculation: 'Для каждой стратегии вычисляется среднее арифметическое выигрышей по всем состояниям природы.',
        steps: [
            'Для каждой строки вычислить сумму всех элементов',
            'Разделить сумму на количество столбцов (состояний природы)',
            'Выбрать стратегию с максимальным средним значение'
        ],
        interpretation: 'Используется при полном отсутствии информации о вероятностях. Предполагает, что все состояния природы равновероятны.'
    }
};

/**
 * Сервис для работы с информацией о критериях
 */
class CriteriaInfoService {
    /**
     * Получение информации о критерии по ключу
     * @param {string} criterionKey - ключ критерия
     * @returns {object} - информация о критерии
     */
    static getCriterionInfo(criterionKey) {
        return CriteriaInfo[criterionKey] || null;
    }

    /**
     * Получение форматированного HTML описания критерия
     * @param {string} criterionKey - ключ критерия
     * @returns {string} - HTML описание
     */
    static getFormattedDescription(criterionKey) {
        const info = this.getCriterionInfo(criterionKey);
        if (!info) return '<p>Информация о критерии не найдена</p>';
        
        let html = `<p><strong>Описание:</strong> ${info.description}</p>`;
        
        if (info.formula) {
            html += `<div class="formula"><strong>Формула:</strong> ${info.formula}</div>`;
        }
        
        if (info.maxFormula) {
            html += `<div class="formula"><strong>Оптимизация:</strong> ${info.maxFormula}</div>`;
        }
        
        if (info.calculation) {
            html += `<p><strong>Методика расчета:</strong> ${info.calculation}</p>`;
        }
        
        if (info.steps && info.steps.length > 0) {
            html += `<p><strong>Алгоритм расчета:</strong></p><ol class="calculation-steps">`;
            info.steps.forEach(step => {
                html += `<li>${step}</li>`;
            });
            html += `</ol>`;
        }
        
        if (info.interpretation) {
            html += `<div class="example-calculation"><strong>Интерпретация:</strong> ${info.interpretation}</div>`;
        }
        
        return html;
    }

    /**
     * Получение списка всех критериев
     * @returns {Array} - массив объектов с информацией о критериях
     */
    static getAllCriteria() {
        return Object.keys(CriteriaInfo).map(key => ({
            key,
            name: CriteriaInfo[key].name,
            description: CriteriaInfo[key].description
        }));
    }

    /**
     * Проверка существования критерия
     * @param {string} criterionKey - ключ критерия
     * @returns {boolean} - true если критерий существует
     */
    static hasCriterion(criterionKey) {
        return criterionKey in CriteriaInfo;
    }
}